---
eip: < preferred 726>
title: Operating Cash Flow (OCF) Standard
description: Defines a protocol for operating cash flow in a NFT community
author: FinancialApeClub(@apefinancialclub)
discussions-to: <URL>
status: Draft
type: Standards Track
category: ERC
created: 2022-10-07
requires: 165, 721, 20
---

## Abstract
This is a standard of operation management and financial rules for NFT communities. This set of smart contract interfaces define NFT, as a community ID pass, having its nature of an equity certificate with its inherent right and interests. Community operation and financial control can only be conducted in following the pre-set rules in the smart contract. This openess and transparency of operating mechanism and financial rules will better reflect the value and rights of community members, and then enhance the confidence and interest of NFT holders in NFT projects.

Interface functions mainly include: 
  1) creating and setting up ledger account for different account subject, 
  2) binding asset inflow source address and asset outflow receiver address to a particular ledger account, 
  3) inflowing (receiving in) and outflowing (sending out) asset (ether and non-ether asset such as ERC20 or ERC721 Tokens), 
  4) NFT royaltiy distribution, 
  5) dividend (benifits sourced from the community, to be distributed to entitled NFT holders) distribution, 
  6) enquirying the net value and accumulated dividend (including multiple types of asset, e.g. ether, ERC20 and ERC-721 tokens) distributed of a given NFT token id.
These functions are centered on finacial control in Operating Cash Flow (OCF),  thus this EIP is titled as Operating Cash Flow (OCF) Standard.

As community ID Pass, the NFT defined in this EIP is EIP-721 compatibable.
  
## Motivation
Due to the lack of an effective ecological economic system in the NFT community, the fast growing NFT market in 2021 has sharply been shrinking. In traditional NFT markets, there is no sustainable financial operation mechanism, the value of holding NFT cannot be clearly reflected, and operation and finacial condition of the fund raised by NFT project team through offering NFT is not disclosed to the NFT holders. This EIP defines a frame for setting the rules for all the fund (operating cash), including NFT offering proceedings and other income sources (opeating imcomes) in the NFT community, to flow in and out, establishes a complete community financial mechanism for the NFT project team and investors in applying the principles of openness and transparecy and binding operating-projects to the community in the smart contract. 
The immutable rules of the operating cash flow (including NFT royalty distribution and dividend distribution), together with community ledger account enquiry functions, implemented in a smart contract complied with this EIP, provides immutability and trasparency of fund flow, which will create a confidence of the NFT community and therefore significantly promote the develpment of the Ethereum ecosystem.

Since NFT tokens minted complied with this protocol is EIP-721 compatible, NFTs of this EIP can circulate in any EIP-721 scenarios and trading platforms.

## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

**Every [EIP-726](./eip-726.md) compliant contract must implement the EIP-726, EIP-721 and [EIP-165](./eip-165.md) interfaces**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ERC-726 Operating Cash Flow Standard
 */
interface IERC726 { 
    /**
     * @notice Define a struct Account, used for recording an account information for a specific
     *         account subject
     *  - name:       name of the account, its length must be non-zero.
     *  - assets:      asset name of the account, its length must be non-zero.
     *  - subjects:   multiple accoount subjects, seperated by semi-columns.
     *  - opProjects: array of names of operating projects under this account.
     *  - opContracs: array of names of operating contracts under this account.
     *  - nonOpProjects: array of names of non-operating projects under this account.
     *  - balance:    balance of the account, its representation needs to use 'decimals' as explained
                      above.
     *  - refAddress: addresses of relevant parities: the project producing income for this account and 
     *                related partner's project, seperated by semi-columns.
     *  - active:     status of the account, balance can be updated only if it is true.
    */
    struct Account {
        string name;
        string[] assets;
        uint8[] decimals;
        address[] assetContracts;
        string subjects;
        // string opProjects;
        // string opContracts;
        // string nonOpContracts;
        uint256[] balances;
        string refAddresses;
        bool active;
    }
  
    /**
     * @notice Define a struct Asset, used in a mapping {string => Asset} assets to be referenced by
     *         struct Account.asset.
     *  - name:     name of the asset, its length must be non-zero.
     *  - decimals: number of decimals that the asset in the account uses for balance, e.g. 3 means
     *              the representation of the value is calculated by dividing the recorded balance 
     *              value by 1,000 (1e3).
     *  - assetContract: address of smart contract for the asset, it does not apply when its asset is 
     *                   ether.
    */
    struct Asset {
        string name;
        uint8 decimals;
        address assetContract;
    }

    /**
     * @dev MUST emit when a NFT is refund successfully.
     * @param owner: Address of owner who requests the refund
     * @param tokenId: Token id refunded for
     * @param amount: amount refunded in Wei
     */
    event Refund(address owner, uint256 tokenId, uint256 amount);
    
    /**
     * @dev MUST emit when an ether inflow is successfully transacted from a source address by
     *      calling etherInflow().
     * @param source: Source address of the ether inflow.
     * @param amount: amount inflowed.
     * @param account: name of ledger account that the ether inflowed to.
     */
    event EtherInflow(address indexed source, uint256 amount, string account);

    /**
     * @dev MUST emit when an ether outflow is successfully transacted to a receiver address by
     *      calling etherOutflow().
     * @param receiver: receiver address of the ether outflow.
     * @param amount: amount outflowed.
     * @param account: name of ledger account that the ether outflowed from.
     */
    event EtherOutflow(address indexed receiver, uint256 amount, string account);
    
    /**
     * @dev MUST emit when a non-ether asset inflow is successfully transacted from a source 
     *      address by calling etherInflow().
     * @param source: Source address of the non-ether asset inflow.
     * @param asset:  name of the asset inflowed.
     * @param amount: amount inflowed.
     * @param account: name of ledger account that the non-ether asset inflowed to.
     */
    event AssetInflow(address indexed source, string asset, uint256 amount, string account);

    /**
     * @dev MUST emit when a non-ether asset outflow is successfully transacted to a receiver 
     *      address by calling etherOutflow().
     * @param receiver: receiver address of the non-ether asset outflow.
     * @param asset:  name of the asset outflowed.
     * @param amount: amount outflowed.
     * @param account: name of ledger account that the non-ether asset outflowed from.
     */
    event AssetOutflow(address indexed receiver, string asset, uint256 amount, string account);

    /**
     * @notice Request a refund for a token.
     * @dev - Caller must be the token owner; the token must not have been transferred; 
     *      - if accumulated dividend distributed exceeds minting cost, it is not allowed to refund.
     *      - The token must be transferred to a pre-bound unified address when refund succeeds.
     * @param  tokenId The token id that the refund requests for.
     * MUST emit a {Refund} event.
     */

    function refund(uint256 tokenId) external;
    
    /**
     * @notice Ether inflows in to this contract account.
     * @dev - Caller should normally be an operating-project fund (operating) address, income fund of the
     *        operating-project inflows in ether wei, its address must be pre-bound to a ledger account
     *        in this smart contract, inflowed ether value is added to the balance of this bound ledger   
     *        account. If caller has not been bound, it is treated as non-operating address,
     *        its inflowed ether value is added to a default ledger account.
     * MUST emit a {EtherInflow} event.
     */        
    function etherInflow() external payable;

    /**
     * @notice Ether outflows from this contract account.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *       - To succeed in outflowing (sending out) ether, it must meet certain conditions.
     * @param recipient: address of which ether outflows to. 'recipient' must be either an operating-
     *        project fund address (operating address), pre-bound to a ledger account in this smart 
     *        contract for ether outflowing, where outflowed ether value is deducted from the balance 
     *        of its bound ledger account, or a NFT holder of this smart contract, where outflowed ether 
     *        value is deducted from the balance of a default ledger account.
     * @param amount: amount of ether to be outflowed.
     * MUST emit a {EtherOutflow} event.        
     */        
    function etherOutflow(address recipient, uint256 amount) external;

    /**
     * @notice Non-ether asset inflows to this contract account.
     * @dev - Caller should normally be a operating-project address, its address must be pre-bound to
     *        a ledger account in this smart contract, inflowed asset amount is added to the balance 
     *        of this bound ledger account. For a non-bound caller (non-operating-income address), 
     *        inflowed asset is added to a default ledger account.
     * @param amount: amount of asset to be inflowed.     
     * MUST emit a {AssetInflow} event.*/        
    function assetInflow(uint256 amount) external;

    /**
     * @notice Non-ether asset outflow from this contract account.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *       - To succeed in outflowing (sending out) asset, it must meet certain conditions.
     * @param recipient: address of which non-ether asset outflows to. 'recipient' must be either a
     *        operating-project address, pre-bound to a ledger account in this smart contract for
     *        asset outflowing, where outflowed asset amount is deducted from the balance of its bound 
     *        ledger account, or a NFT holder of this smart contract, where outflowed asset amount is 
     *        deducted from the balance of a default account.
     * @param amount: amount of asset to be outflowed.
     * MUST emit a {AssetOutflow} event.        
     */        
    function assetOutflow(address recipient, uint256 amount) external;

    /**
     * @notice Create an Account.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     * @param accountName:: name of the account to create, its length must be non-zero.
     * @param subjects:   multiple accoount subjects, seperated by semi-columns.
     * @param refAddresses: addresses of relevant parities: the project producing income for this account  
     *                    and related partner's project.
     */        
    function createAccount(string memory accountName, string memory subjects, 
                           string memory refAddresses) external;

    /**
     * @notice Delete an Account.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *      - balance of the account must be zero.
     * @param accountName:: name of the account to create, its length must be non-zero.
     */        
    function deleteAccount(string memory accountName) external;
    
    /**
     * @notice Change Account name.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     * @param oldName: name of the account to be changed, it must exist.
     * @param newName: name of the account to be changed to.
     */
    function changeAccountName(string memory oldName, string memory newName) external;
    
    /**
     * @notice Update Account setting.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *      - balance of the account must be zero.
     * @param accountName:: name of the account to change its setting, it must exist.
     * @param subjects:   multiple accoount subjects, seperated by columns. If this param only contains 
     *                    whitespaces, or length is zero, no update will be taken for this item. 
     * @param refAddresses: addresses of relevant parities: the project producing income for this account  
     *                    and related partner's project. If this param only contains whitespaces, or 
     *                    its length is zero, no update will be taken for this item. 
     */
    function updateAccountSetting(string memory accountName, string memory subjects, 
                           string memory refAddresses) external;
    
    /**
     * @notice Set active status of an Account to either true or false.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     * @param accountName: name of the account for which the active status to set, it must exist.
     * @param active: active status of the account to set: either true or false.
     */        
    function setAccountStatus(string memory accountName, bool active) external;

   /**
     * @notice Define an asset.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     * @param assetName: name of the aasset to define.
     * @param decimals: demimals of the asset (see struct Asset defination).
     * @param assetContract: address of asset smartContract (see struct Asset defination).
     */
    
    function defineAsset(string memory assetName, uint8 decimals, address assetContract) external;
    /**
     * @notice Delete an asset.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     * @param assetName: name of the aasset to delete.
     */
    function deleteAsset(string memory assetName) external;

    /**
     * @notice Add an asset item under a ledger account.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     * @param accountName: name of the account under which an asset item is to be added.
     * @param item: asset item to be added.
     */
    function addAssetToLegderAccount(string memory accountName, string memory item) external;

    /**
     * @notice Delete an asset item from a ledger account.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     * @param accountName: name of the account under which an asset item is to be deleted.
     * @param item: asset item to be deleted.
     */
    function deleteAssetFromLedgerAccount(string memory accountName, string memory item) external;

    // /**
    //  * @notice Add an operating-project item under an account.
    //  * @dev - Caller MUST be the contract owner or an authorized operator.
    //  * @param accountName: name of the account under which an operating-project item is to be added.
    //  * @param item: operating-project item to be added.
    //  */
    // function addOperatingProject(string memory accountName, string memory item) external;

    // /**
    //  * @notice Add an operating-contract item under an account.
    //  * @dev - Caller MUST be the contract owner or an authorized operator.
    //  * @param accountName: name of the account under which an operating-contract item is to be added.
    //  * @param item: operating-contract item to be added.
    //  */
    // function addOperatingContract(string memory accountName, string memory item) external ;

    // /**
    //  * @notice Add a non-operating-contract item under an account.
    //  * @dev - Caller MUST be the contract owner or an authorized operator.
    //  * @param accountName: name of the account under which an non-operating-contract item is to be added.
    //  * @param item: non-operating-contract item to be added.
    //  */
    // function addNonNonOperatingContract(string memory accountName, string memory item) external;

    // /**
    //  * @notice Update an operating-project item under an account with an index.
    //  * @dev - Caller MUST be the contract owner or an authorized operator.
    //  * @param accountName: name of the account under which an operating-project item is to be updated.
    //  * @param index: index of the operating-project item which is to be updated.
    //  * @param item: operating-project item to be updated.
    //  */
    // function updateOperatingProject(string memory accountName, uint256 index, string memory item) external;

    // /**
    //  * @notice Update an operating-contract item under an account with an index.
    //  * @dev - Caller MUST be the contract owner or an authorized operator.
    //  * @param accountName: name of the account under which an operating-contract item is to be updated.
    //  * @param index: index of the operating-contract item which is to be updated.
    //  * @param item: operating-contract item to be updated.
    //  */
    // function updateOperatingContract(string memory accountName, uint256 index, string memory item) external;

    // /**
    //  * @notice Update a non-operating-contract item under an account with an index.
    //  * @dev - Caller MUST be the contract owner or an authorized operator.
    //  * @param accountName: name of the account under which an non-operating-contract item is to be updated.
    //  * @param index: index of the non-operating-contract item which is to be updated.
    //  * @param item: non-operating-contract item to be updated.
    //  */
    // function updateNonOperatingContract(string memory accountName, uint256 index, string memory item) external;

    /**
     * @notice Bind an address to a ledger account that the address will inflow asset to this account.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *      - One address is only allowed to be bound to one ledger account for inflowing asset, while 
     *        multiple addresses may be bound to one ledger account.
     * @param inflower: address to be bound to the ledger account.
     * @param accoundName: name of the ledger account to which the address inflower is bound to.      
     */        
    function bindInflowAccount(address inflower, string memory accoundName) external;

    /**
     * @notice Bind an address to an ledger account that the account in this contract will outflow
     *         asset to the address.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *      - One address is only allowed to be bound to one ledger account for outflowing asset, while  
     *        multiple addresses may be bound to one ledger account.
     * @param receiver: address to be registered to the account.
     * @param accoundName: name of the account to which the address receiver is bound to.
     */        
    function bindOutflowAccount(address receiver, string memory accoundName) external;

    /**
     * @notice Get all ledger accounts infomation of this NFT community.
     * @return an array of Account struct
     */        
    function accounts() external view returns(Account[] memory);

    /**
     * @notice Register NFT holders who will be entitled to for royalty distribution.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *      - Implemetation of certain rules to determine who will be entitled to the royalty
     *        distribution.
     */        
    function registerRoyaltyDistributees() external;

    /**
     * @notice Distribute royalty to certain NFT holders which are determined by registerRoyaltyDistributees{}.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     */        
    function distributeRoyalty() external;

    /**
     * @notice Register dividend beneficiaries who are the holders of this smart contract NFTs.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     *      - Implemetation of certain rules to determine who will be entitled to the dividend
     *        distribution.
     */      
    function registerDividendBenificiaries() external;

    /**
     * @notice Distribute dividend to beneficiaries who are determined by 
     *         registerDividendBenificiaries{}.
     * @dev - Caller MUST be the contract owner or an authorized operator.
     */        
    function distributeDividend() external;

    /**
     * @notice Get net value in ether wei of a token Id.
     * @param tokenId:  tokenId of which net value to be retreived, it must exist.
     * @return net value in ether wei
     */        
    function netValueOf(uint256 tokenId) external returns(uint256);

    /**
     * @notice Get accumulated dividend already distributed of a token Id.
     * @param tokenId:  Token Id of which dividend accumulated, it must exist.
     * @return dividend value in ether wei and percentage to its purchase cost.
     */        
    function dividendOf(uint256 tokenId) external returns(uint256, uint256);
}
## Rationale
In order to be more widely applicable, ledger accounts are designed for any digital asset, ether asset and non-ether asset. Non ether asset is described with asset name, decimals for balance value and asset smart contract address. Therefore a struct Asset{} and a struct LedgerAccount{} is defined to accomodate Asset and Ledger Account information respectively.

Asset inflow sources are divided into two categories: the address of a operating-project (referred to as operating) and the address of others (referred to as non-operating). 
Outflow recipients must be either the address of operating-project (operating),  or  the address of the holder of this smart contract NFT (non-operating).

Each asset inflow source and outflow recipient needs to be bound to certain corresponding ledger account for asset inflowing and outflowing to be recorded to the right ledger account, and more importantly, this can enchance the security of the asset flow.
  
In addition to address-account binding, more detailed and specific rules need to be implemented for asset outflowing, e.g. pre-set conditions of duration and amount must be met for asset outflowing. Amount and benificiaries must be determined in a immutable way for royalty distribution and dividend distribution.
  
Overall, this EIP defines a standard of recording operationg-projects, setting financial rules, creating and managing ledger account, registering NFT royalty and dividend benificiaries and distributing royalty and dividends, thus establishes a community of NFT with equity cerificate nature.
  
## Backwards Compatibility
This EIP is backward compatible with EIP-721.

## Security Considerations
The state-mutable functions of this EIP are only allowed to be called by the ERC-726 contract owner, authrized operator, or pre-bound address, except the etherInflow() and assetInflow(). Implementations of this EIP must obey this principle.

Special attention should be paid to vulnerability of asset (both ether and non-ether assets) inflow/outflow functions for hacking with either amount or address. Signature-verification or Merkle-proof may be implemented to enhance the security. 

Since this EIP is EIP-721 compatible, any wallets and smart contracts that can hold and manipulate standard EIP-721 tokens will have no risks of asset loss for EIP-726 tokens.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
